# Python Decorators Explained: A CodeGuru Tutorial

A detailed explanation of decorators generated by CodeGuru's "Deep Dive" mode.

**Command used:**
```bash
python chat.py
```
**Question:**
"Explain how Python decorators work internally, including closures"

---

## ü§ñ CodeGuru: Deep Dive into Decorators

### 1. The Core Concept

A decorator is syntactic sugar for a function that wraps another function.

When you see:
```python
@my_decorator
def my_func():
    pass
```

It is equivalent to:
```python
def my_func():
    pass
my_func = my_decorator(my_func)
```

The decorator function takes a function object, and returns a *new* function object (usually a wrapper).

---

### 2. Building Blocks: Closures

To understand decorators, you must understand closures. 
A closure is a function that remembers values from its enclosing scope.

```python
def make_multiplier(x):
    # This inner function remembers 'x'
    def multiplier(n):
        return x * n
    return multiplier

times3 = make_multiplier(3)
# times3 is a closure that remembers x=3
print(times3(10))  # 30
```

---

### 3. Step-by-Step Decorator

Here's a logging decorator built from scratch:

```python
import functools

def log_calls(func):
    """Decorator that logs function calls."""
    
    # Use wraps to preserve original func metadata
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        # 1. Before call logic
        print(f"Calling {func.__name__} with {args}, {kwargs}")
        
        # 2. Call original function
        result = func(*args, **kwargs)
        
        # 3. After call logic
        print(f"{func.__name__} returned {result}")
        
        return result
    
    return wrapper

@log_calls
def add(a, b):
    """Adds two numbers."""
    return a + b

# Usage
x = add(5, 3)
# Output: 
# Calling add with (5, 3), {}
# add returned 8
```

---

### 4. Advanced: Decorators with Arguments

If you want `@retry(attempts=3)`, you need a function that returns a decorator. It's a "decorator factory".

```python
def retry(attempts=3):
    # This is the factory
    def decorator(func):
        # This is the actual decorator
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            last_exception = None
            for _ in range(attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    last_exception = e
                    print(f"Retrying...")
            raise last_exception
        return wrapper
    return decorator

@retry(attempts=2)
def unstable_api():
    raise ConnectionError("Failed")
```

---

### 5. Common Pitfalls

‚ùå **Forgetting `functools.wraps`**
Without it, your decorated function loses its name and docstring (`__name__` becomes 'wrapper').

‚ùå **Using mutable defaults in decorators**
Avoid `@cache(data={})`. Use unhashable type logic carefully.

‚ùå **Decorating methods vs functions**
Normally works fine, but class-level decorators (on `__init__`) can be tricky with `self`.

---

*Generated by CodeGuru using Groq Llama 3 70B.*
