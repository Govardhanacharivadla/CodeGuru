# Async Patterns in Python: A CodeGuru Explanation

This example demonstrates how CodeGuru explains complex async patterns.

**Command used:**
```bash
python chat.py
```

**Question:**
"Explain async/await vs threading in Python with examples"

---

## ü§ñ CodeGuru Explanation

Here's the breakdown of Asynchronous Programming vs Threading in Python:

### 1. The Core Concept

#### Threading (Parallel-ish)
- **Best for:** I/O bound tasks (network, disk) where tasks block.
- **How it works:** OS switches between threads (preemptive multitasking).
- **Python constraint:** The GIL (Global Interpreter Lock) prevents true parallel CPU execution.
- **Analogy:** Hiring multiple workers to do tasks. While one waits for delivery, another works.

#### Asyncio (Concurrent)
- **Best for:** High-concurrency I/O (thousands of connections).
- **How it works:** Single thread, cooperative multitasking. Tasks yield control when waiting.
- **Analogy:** One super-efficient worker who juggles tasks. While waiting for toast, they pour coffee.

---

### 2. Code Examples

#### Threading Example
```python
import threading
import time

def worker(name):
    print(f"Worker {name} starting")
    time.sleep(2)  # Blocking I/O simulation
    print(f"Worker {name} done")

# Create threads
t1 = threading.Thread(target=worker, args=("A",))
t2 = threading.Thread(target=worker, args=("B",))

t1.start()
t2.start()

t1.join()
t2.join()
```

#### Asyncio Example
```python
import asyncio

async def worker(name):
    print(f"Worker {name} starting")
    await asyncio.sleep(2)  # Non-blocking pause
    print(f"Worker {name} done")

async def main():
    # Run concurrently
    await asyncio.gather(
        worker("A"),
        worker("B")
    )

asyncio.run(main())
```

---

### 3. Key Differences

| Feature | Threading | Asyncio |
|---------|-----------|---------|
| **Model** | Preemptive | Cooperative (await) |
| **Switching** | OS handles it | Code yields control |
| **Overhead** | High (memory per thread) | Low (objects) |
| **Race Conditions** | High risk (locks needed) | Lower risk (control explicit) |
| **Best Use** | Heavy I/O, simple apps | High-scale network apps |

---

### 4. Best Practices

‚úÖ **Use Asyncio when:**
- Building web servers (FastAPI, Sanic)
- Making many network requests (httpx, aiohttp)
- Handling WebSocket connections

‚úÖ **Use Threading when:**
- Working with legacy blocking libraries (requests, db drivers)
- Simple scripts where async overhead isn't needed
- GUI applications (to keep UI responsive)

‚ùå **Common Pitfall:**
Don't use `time.sleep()` in async code! It blocks the *entire* event loop. 
Always use `await asyncio.sleep()`.

---

*This explanation was generated by CodeGuru using Groq Llama 3 70B.*
